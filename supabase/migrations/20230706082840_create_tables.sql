-- CUSTOM TYPES
create type public.user_status as enum ('ONLINE', 'OFFLINE');
create type public.vote_direction as enum ('UP', 'DOWN');

-- USERS
create table public.profiles (
  id          uuid not null primary key, -- UUID from auth.users
  username    text,
  bio         text,
  status      user_status default 'OFFLINE'::public.user_status not null,
  unique(username)
);
comment on table public.profiles is 'Profile data for each user.';
comment on column public.profiles.id is 'References the internal Supabase Auth user.';

-- POSTS
create table public.posts (
  id            bigint generated by default as identity primary key,
  created_at    timestamp with time zone default timezone('utc'::text, now()) not null,
  title         text,
  url           text,
  score         integer default 0 not null,
  profile_id    uuid references public.profiles (id) not null
);
comment on table public.posts is 'Individual posts published by each user.';

-- COMMENTS
create table public.comments (
  id            bigint generated by default as identity primary key,
  profile_id    uuid references public.profiles (id) not null,
  post_id       bigint references public.posts (id) not null,
  message       text not null,
  created_at    timestamp with time zone not null default now()
);
comment on table public.comments is 'Individual comments published by each user.';
comment on table public.comments is e'@graphql({"totalCount": {"enabled": true}})';

-- VOTES
create table public.votes (
  post_id       bigint references public.posts not null,
  profile_id    uuid references public.profiles (id) not null,
  direction     vote_direction not null,
  created_at    timestamp with time zone not null default now(),
  primary key(post_id, profile_id),
  unique(post_id, profile_id)
);
comment on table public.votes is 'Post votes by each user.';
comment on table public.votes is e'@graphql({"totalCount": {"enabled": true}})';

-- Create a trigger function to inserts a row into profiles
create function public.handle_new_user()
returns trigger as
$$
  begin
    insert into public.profiles (id, username)
    values (new.id, split_part(new.email, '@', 1) || '-' || floor(random() * 10000));
    return new;
  end;
$$ 
language plpgsql security definer;

-- Create a trigger to execute the function every time a user is created
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();

-- Create a trigger function to update the post score
create function public.update_post_score()
  returns trigger as
$$
begin
  if TG_OP = 'INSERT' then
    if new.direction = 'UP' then
      update public.posts
      set score = score + 1
      where id = new.post_id;
    elsif new.direction = 'DOWN' then
      update public.posts
      set score = score - 1
      where id = new.post_id;
    end if;
  elsif TG_OP = 'DELETE' then
    if old.direction = 'UP' then
      update public.posts
      set score = score - 1
      where id = old.post_id;
    elsif old.direction = 'DOWN' then
      update public.posts
      set score = score + 1
      where id = old.post_id;
    end if;
  end if;
  
  return new;
end;
$$
language plpgsql security definer;

-- Create a trigger to execute the function when a new vote is added
create trigger on_vote_created
after insert or delete on public.votes
for each row
execute function public.update_post_score();
